<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<!-- unload - beforeunload 이벤트에서 반환한 값을 처리한다. -->
<body onkeydown="keyDown()" onkeyup="keyUp()" onunload="exit()">
    <!-- 방 정보 구역 -->
    <div id="titleArea">
        <b id="title" th:text="'방 번호 : ' + ${metaRoom.idx} + '   |   ' + '(스터디)' + ' 방 제목 : ' + ${metaRoom.metaTitle} + ' ( ' + ${metaRoom.metaRecruitingPersonnel} + ' / ' + ${metaRoom.metaPersonnel} + ' )'"></b>
    </div>

    <!-- 상단 왼쪽 참가자 구역 -->
    <div id="menuBar" style="border: 2px solid black; box-sizing: border-box; width: 80%; height: 10%; margin-bottom: 0.5%; float: left;">
        <!-- 참가자 코드 -->
        <div th:each="participant : ${participantList}" th:id="${participant.metaNickname}" style="border: 1px solid black; box-sizing: border-box; width: 10%; height: 100%; float: left;">
            <b th:if="${metaRoom.metaMaster == nickImage.nickname}" style="border: 1px solid black; box-sizing: border-box; cursor: pointer; float: left;">X</b>
            <img th:src="@{/imagePath/} + ${participant.metaProfileImage}" style="width: 50%; height:100%; float: left;">
            <div th:if="${participant.metaNickname == metaRoom.metaMaster}"><b style="color: red;">방장</b></div>
            <b th:text="${participant.metaNickname}"></b>
        </div>
    </div>

    <!-- 상단 오른쪽 메뉴바 구역 -->
    <div style="border: 2px solid black; box-sizing: border-box; width: 19.5%; height: 10%; margin-bottom: 0.5%; float: right;">
        <input type="button" value="나가기" th:onclick="|location.href='@{/meta/exit(idx = ${metaRoom.idx})}'|" style="width: 25%; height: 100%;">
    </div>

    <!-- 메타버스 -->
    <canvas id="canvas" style="border: 2px solid black; box-sizing: border-box; width: 80%; height: 80%; float: left;"></canvas>

    <!-- 채팅 구역 -->
    <div id="chatArea" style="text-align: center; border: 2px solid black; box-sizing: border-box; width: 19.5%; height: 80%; float: right; overflow-y: scroll;">
        <div style="text-align: center;">채팅</div><br>
        <!-- 메시지 코드 -->
        <div style="text-align: left;">
        </div>
    </div>

    <!-- 녹음 구역 -->
    <div id="recordArea" style="border: 2px solid black; box-sizing: border-box; width: 80%; height: 5%; margin-top: 0.5%; float: left;">
        <audio id="record" controls style="width: 70%; height: 100%; float: left;"></audio>
        <input id="btnRecordSend" type="button" value="녹음 전송" style="width: 10%; height: 100%; float: right;" disabled>
        <input id="btnRecordStop" type="button" value="녹음 정지" style="width: 10%; height: 100%; float: right;" disabled>
        <input id="btnRecordStart" type="button" value="녹음 시작" style="width: 10%; height: 100%; float: right;">
    </div>

    <!-- 메시지 입력란 -->
    <div style="border: 2px solid black; box-sizing: border-box; width: 19.5%; height: 5%; margin-top: 0.5%; float: right;">
        <input id="btnSend" type="button" value="보내기" onclick="send()" style="width: 25%; height: 100%; float: right;">
        <input id="message" type="text" style="width: 70%; height: 90%; float: left;" placeholder = "채팅 입력란">
    </div>
<!-------------------------------------------------------js 구역-------------------------------------------------------->
    <!-- SockJS 사용을 위한 js를 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <!-- Stomp 사용을 위한 js를 추가 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <!-- Ajax 사용을 위한 js를 추가 -->
    <script src="/js/httpRequest.js"></script>

    <!---------------------------------------------------- 채팅 구역 ----------------------------------------------------->
    <script th:inline="javascript">
        //////////////////////////////////////////////////// 변수 구역 ////////////////////////////////////////////////////
        var metaIdx = [[${metaRoom.idx}]]; // 방 번호
        var metaTitle = [[${metaRoom.metaTitle}]]; // 방 제목
        var metaRecruitingPersonnel = [[${metaRoom.metaRecruitingPersonnel}]]; // 참여중인 인원
        var metaPersonnel = [[${metaRoom.metaPersonnel}]]; // 모집인원
        var metaMaster = [[${metaRoom.metaMaster}]]; // 방장 닉네임
        var nickname = [[${nickImage.nickname}]]; // 로그인 유저의 닉네임
        var profileImage = [[${nickImage.profileImage}]]; // 로그인 유저의 프로필 사진
        // Date.now() - UTC 기준으로 1970년 1월 1일 0시 0분 0초부터 현재까지 경과된 밀리 초를 반환한다.
        let start = ""; // 시작 시간
        let end = ""; // 메시지 전송 시간
        let count = ""; // 전송된 메시지 수
        let sendMessage = ""; // 메시지 전송 상태
        let message = document.getElementById("message"); // 메시지 작성란
        let entryCheck = [[${entryCheck}]]; // 입장 체크값
        let localStorage = window.localStorage; // 로컬 스토리지 객체 생성
        let boomTimeoutId; // 방장 퇴장 setTimeout
        //////////////////////////////////////////////////// 소켓 구역 ////////////////////////////////////////////////////
        // 1. SockJS를 생성한다. (StompWebSocketConfig에서 설정한 Endpoint와 동일하게 맞춰준다.)
        var sockJs = new SockJS("/ws/meta");
        // 2. 생성된 SockJS를 Stomp에 전달한다.
        var stomp = Stomp.over(sockJs);

        // 3. connect가 이뤄지면 실행한다.
        stomp.connect({}, function () {
            // connect가 이뤄지면 콘솔에 로그를 찍는다.
            console.log("STOMP Connection");

            // 5. subscribe(path, callback)으로 메시지를 받을 수 있다.
            //    StompChatController에서 SimpMessagingTemplate를 통해 전달한 DTO를 여기서 콜백 메소드 파라미터로 전달 받는다.
            stomp.subscribe("/sub/meta/studyRoom/" + metaIdx, function (chat) {
                // 채팅에 필요한 것들
                var chatArea = document.getElementById("chatArea"); // 메시지가 작성될 채팅 구역
                var str = ""; // 메시지 코드가 작성될 변수
                // 6. 5에서 전달받은 메시지의 headers에서 type 값이 "record"인지 체크한다.
                // 6-1. type 값이 "record"인 경우
                if ( chat.headers.type == "record" ) {
                    // 7. document.createElement()를 사용하여, 전달 받은 녹음된 오디오 메시지를 코드로 작성해 채팅 구역에 올린다.
                    // document.createElement() - 지정한 태그 이름을 가진 HTML 요소를 생성하는 메소드이다.
                    //                            이 메소드를 사용하면 동적으로 HTML 요소를 생성할 수 있다.
                    // audio(오디오) 태그를 생성한다.
                    let audioTag = document.createElement("audio");
                    // 5에서 전달 받은 메시지의 body에서 녹음된 오디오 데이터를 가져와 audio(오디오) 태그의 소스로 전달한다.
                    audioTag.src = chat.body;
                    // audio(오디오) 태그의 컨트롤러를 설정한다.
                    audioTag.controls = true;
                    // b 태그를 생성한다.
                    let bTag = document.createElement("b");
                    // b 태그의 display를 flex로 설정하는 style을 추가한다.
                    bTag.style.display = "flex";
                    // b 태그의 align-items를 center로 설정하는 style을 추가한다.
                    bTag.style.alignItems = "center";
                    // document.createTextNode() - 지정한 텍스트를 포함하는 새로운 Text 노드를 생성하는 메소드이다.
                    //                             이 메소드를 사용하여 동적으로 HTML 요소의 텍스트를 업데이트할 수 있다.
                    //                             이 메소드는 document.createElement()와 함께 사용하여 동적으로 HTML 요소를 생성하는 데 사용된다.
                    // b 태그에 넣을 내용을 작성해 TextNode로 생성한다.
                    let bContent = document.createTextNode(nickname + " : ");
                    // b 태그에 TextNode로 생성한 내용을 넣는다.
                    bTag.appendChild(bContent);
                    // b 태그에 audio(오디오) 태그를 넣는다.
                    bTag.appendChild(audioTag);
                    // div 태그를 생성한다.
                    let divTag = document.createElement("div");
                    // div 태그의 text-align을 left로 설정하는 style을 추가한다.
                    divTag.style.textAlign = "left";
                    // div 태그에 b 태그를 넣는다.
                    divTag.appendChild(bTag);
                    // 채팅 구역에 div 태그를 올린다.
                    chatArea.appendChild(divTag);
                    // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                    chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;
                    ////////////////////////////////////////////////////////////////////////////////////////////////////
                    // 채팅 구역에 올라간 audio(오디오) 태그를 모두 선택하여 audioTags 변수에 NodeList 형태로 저장한다.
                    // querySelectorAll - HTML 문서 내에서 특정 CSS 선택자에 해당하는 요소들을 찾아 NodeList 형태로 반환하는 메소드이다.
                    // NodeList - DOM에서 사용되는 객체로, 여러 개의 노드(HTML 요소, 속성, 텍스트 등)가 포함될 수 있는 리스트 형태의 객체를 나타낸다.
                    //            일반적으로 querySelectorAll 메소드로 선택된 요소들을 반환하는데 사용된다.
                    //            NodeList 객체는 배열과 유사하게 인덱스를 사용하여 접근할 수 있으며, length 속성을 통해 그 길이를 알 수 있다.
                    //            하지만 NodeList는 배열이 아니므로, 배열 메소드를 사용할 수 없다.
                    let audioTags = document.querySelectorAll("#chatArea audio");
                    // forEach 메소드를 사용하여 audioTags 변수에 저장되어 있는 NodeList의 각 요소에 대하여 이벤트 리스너를 등록한다.
                    audioTags.forEach(audio => {
                        // forEach 메소드를 사용하여 audioTags 변수에 저장되어 있는 NodeList에서 가져온 각 audio(오디오) 태그마다,
                        // "ended" 이벤트가 발생하면 해당 이벤트를 처리하는 콜백 메소드를 등록한다.
                        // ended - 오디오나 비디오 등의 미디어가 재생이 끝났을 때 발생한다.
                        audio.addEventListener("ended", () => {
                            // 각 audio(오디오) 태그의 재생이 종료되면, audio(오디오) 태그에 작성되어 있는 소스를 그대로 재작성한다.
                            // 이는 오디오 재생이 끝나고 다시 재생할 때, 오디오 소스가 초기화되도록 하는 역할을 한다.
                            // 이렇게 하는 이유는, 오디오 태그의 재생이 종료되고 나서 다시 오디오 태그가 재생될 때, 병합된 오디오 데이터를 온전히 다시 재생하기 위해서이다.
                            // 이렇게 하지 않으면, 오디오 태그의 재생이 종료되고 나서 다시 오디오 태그가 재생될 때, 병합된 오디오 데이터중 마지막 오디오 데이터만 재생된다.
                            // 하나의 오디오 데이터는 문제가 없지만, 병합된 여러개의 오디오 데이터는 이런 문제가 발생해 임시방편으로 찾아낸 방법이다.
                            audio.src = audio.src;
                        });
                    });
                // 6-2. type 값이 "record"가 아닌 경우
                } else {
                    // 7. JSON형식으로 넘어온 DTO를 JavaScript형식으로 변환한다.
                    //    JSON.parse(변환 대상) - JSON 문자열을 JavaScript 값이나 객체로 변환한다.
                    var content = JSON.parse(chat.body);
                    // 7-1. 변환된 DTO를 사용하기 편하게 각각 변수에 나눠놓는다.
                    var writer = content.writer; // 작성자
                    var message = content.message; // 메시지
                    var participant = content.participant; // 참가자 닉네임
                    var profileImage = content.profileImage; // 참가자 프로필 사진
                    var exit = content.exit; // 퇴장자 닉네임
                    var recruitingPersonnel = content.metaRecruitingPersonnel; // 참여중인 인원
                    let timePassed = end - start; // 처음 메시지 전송후 1초 이내 다음 메시지 전송까지의 경과 시간 - 1초 이후 시작 시간 초기화
                    let master = content.master; // 방장 닉네임
                    let metaType = content.type; // 메시지 타입

                    // 8. 참여중인 인원이 바뀌는 경우
                    if ( recruitingPersonnel != null ) {
                        // 현재 작성되어 있는 방 정보를 바뀐 인원대로 변경해줘야 하기에 먼저 이전 방 정보를 제거하고 다시 올린다.

                        // id를 통해 작성되어 있는 방 정보을 가져와 title 변수에 저장한다.
                        var title = document.getElementById("title");
                        // title에 저장된 방 정보 id를 사용하여 해당 참가자를 삭제한다.
                        title.remove();

                        // id를 통해 방 정보가 작성될 구역을 가져와 titleArea 변수에 저장한다.
                        var titleArea = document.getElementById("titleArea");

                        // 방 정보 코드를 작성한다.
                        var prt = '<b id="title">';
                        prt += '방 번호 : ';
                        prt += metaIdx;
                        prt += '   |    (스터디) 방 제목 : ';
                        prt += metaTitle;
                        prt += ' ( '
                        prt += recruitingPersonnel;
                        prt += ' / ';
                        prt += metaPersonnel;
                        prt += ' )';
                        prt += '</b>';
                        // 작성한 방 정보 코드를 방 정보 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        titleArea.insertAdjacentHTML("afterbegin", prt);

                        // 전역 변수에 선언되어 있는 참여중인 인원을 새로 받아온 참여중인 인원으로 변경한다.
                        metaRecruitingPersonnel = recruitingPersonnel;
                    }

                    // 9. 새로 들어온 참가자가 있는 경우
                    if ( participant != null ) {
                        // 참가자가 새로 들어온게 아닌 새로고침한 경우 - 현재 작성되어 있는 참가자랑 중복되지 않게 먼저 이전 참가자를 삭제하고 다시 올린다.

                        // 작성자 닉네임의 id를 통해 참가자 구역에 작성되어 있는 작성자를 가져와 ptr 변수에 저장한다.
                        var ptr = document.getElementById(writer);
                        // 가져온 참가자가 존재하는 경우
                        if ( ptr != null ) {
                            // ptr에 저장된 참가자 id를 사용하여 해당 참가자를 삭제한다.
                            ptr.remove();
                        }

                        // id를 통해 참가자가 작성될 구역을 가져와 menuBar 변수에 저장한다.
                        var menuBar = document.getElementById("menuBar");

                        // 참가자 코드를 작성한다.
                        var mtr = '<div id="' + writer + '" style="border: 1px solid black; box-sizing: border-box; width: 10%; height: 100%; float: left;">';
                        if ( metaMaster == nickname ) {
                            mtr += '<b style="border: 1px solid black; box-sizing: border-box; cursor: pointer; float: left;">' + 'X' + '</b>';
                        }
                        mtr += '<img src="/imagePath/' + profileImage + '" style="width: 50%; height: 100%; float: left;">';
                        if ( metaMaster == writer ) {
                            mtr += '<div>' + '<b style="color: red;">' + '방장' + '</b>' + '</div>';
                        }
                        mtr += '<b>' + writer + '</b>';
                        // 작성한 참가자 코드를 참가자 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        menuBar.insertAdjacentHTML("beforeend", mtr);
                    }

                    // 10. 메시지 타입 값에 따라 나눈다.

                    // 10-1. 메시지 타입이 "enter"일 경우
                    // 첫 입장
                    if ( metaType == "enter" ) {
                        // 메시지 코드를 작성한다.
                        str = '<div style="text-align: left;">';
                        str += '<b>' + message + '</b>';
                        str += '</div>'
                        // 작성한 메시지 코드를 채팅 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        chatArea.insertAdjacentHTML("beforeend", str);
                        // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                        chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;
                    }

                    // 10-2. 메시지 타입이 "reEnter"일 경우
                    // 재입장(새로고침)
                    if ( metaType == "reEnter" ) {
                        // 전달 받은 메시지가 존재하는지 체크한다.
                        // 메시지가 존재하지 않는 경우
                        if ( message == null ) {
                            // 아무 작업 없이 돌아간다.
                            return;
                        // 메시지가 존재하는 경우
                        } else {
                            // 메시지 코드를 작성한다.
                            str = '<div style="text-align: left;">';
                            str += '<b>' + message + '</b>';
                            str += '</div>'
                            // 작성한 메시지 코드를 채팅 구역에 올린다.
                            // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                            // position에는 총 4가지의 옵션이 있다.
                            // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                            // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                            // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                            // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                            chatArea.insertAdjacentHTML("beforeend", str);
                            // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                            chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;
                        }
                    }

                    // 10-3. 메시지 타입이 "chat"일 경우
                    // 채팅
                    if ( metaType == "chat" ) {
                        // 메시지 코드를 작성한다.
                        str = '<div style="text-align: left;">';
                        str += '<b>' + writer + ' : ' + message + '</b>';
                        str += '</div>'
                        // 작성한 메시지 코드를 채팅 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        chatArea.insertAdjacentHTML("beforeend", str);
                        // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                        chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;
                    }

                    // 10-4. 메시지 타입이 "delete"일 경우
                    // 방장 퇴장
                    if ( metaType == "delete" ) {
                        // 메시지 코드를 작성한다.
                        str = '<div style="text-align: left; color: red;">';
                        str += '<b>' + '공지 : 방장이 탈주하여 1분뒤 방이 터집니다' + '</b>';
                        str += '</div>'
                        // 작성한 메시지 코드를 채팅 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        chatArea.insertAdjacentHTML("beforeend", str);
                        // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                        chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;

                        // id를 통해 참가자 구역에서 방장을 가져온다.
                        var mtr = document.getElementById(writer);
                        // 가져온 방장 id를 이용하여 방장을 참가자 구역에서 삭제한다.
                        mtr.remove();

                        // 방장 퇴장 후 방 삭제 메시지를 채팅 구역에 올리고, 방장을 참가자 구역에서 삭제한 뒤,
                        // setTimeout 메소드를 사용하여 방장이 퇴장한지 60000ms(1분)이 경과하면 방이 삭제되도록 한다.
                        // 그리고 boomTimeoutId 변수에 setTimeout 메소드로 반환된 타이머 ID를 저장하여,
                        // 타이머가 실행되는 동안 ID를 사용하여 취소할 수 있도록 한다.
                        boomTimeoutId = setTimeout(function() {
                            // 방이 삭제될 때는 아무 경고창 없이 바로 나가질 수 있게 이벤트 핸들러를 제거해 놓는다.
                            // beforeunload 이벤트 핸들러를 제거한다.
                            window.removeEventListener("beforeunload", handleBeforeUnload);
                            // onunload 이벤트 핸들러를 제거한다.
                            document.body.removeAttribute("onunload");
                            // 방 삭제 URL에 파라미터로 방 번호와 닉네임을 가져가 방 삭제 후 바로 퇴장한다.
                            location.href = "/meta/delete?idx=" + metaIdx + "&nickname=" + nickname;
                        }, 60000);
                    }

                    // 10-5. 메시지 타입이 "cancel"일 경우
                    // 방장 퇴장 후 1분 이내 재입장
                    if ( metaType == "cancel" ) {
                        // boomTimeoutId에 저장된 setTimeout ID를 사용하여 실행 중인 타이머를 취소한다.
                        clearTimeout(boomTimeoutId);

                        // 메시지 코드를 작성한다.
                        str = '<div style="text-align: left; color: blue;">';
                        str += '<b>' + '공지 : 방장이 다시 입장하여 방이 유지됩니다.' + '</b>';
                        str += '</div>'
                        // 작성한 메시지 코드를 채팅 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        chatArea.insertAdjacentHTML("beforeend", str);
                        // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                        chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;
                    }

                    // 10-6. 메시지 타입이 "exit"일 경우
                    // 유저 퇴장
                    if ( metaType == "exit" ) {
                        // 메시지 코드를 작성한다.
                        str = '<div style="text-align: left;">';
                        str += '<b>' + message + '</b>';
                        str += '</div>'
                        // 작성한 메시지 코드를 채팅 구역에 올린다.
                        // insertAdjacentHTML( position, html ) - position에 따른 위치에 html 요소를 추가 한다.
                        // position에는 총 4가지의 옵션이 있다.
                        // 1. beforebegin : 타겟 요소 전(형제 요소)에 생성한다. - 시작 태그의 앞 (형제 요소)
                        // 2. afterbegin : 타겟 요소 다음(자식 요소)에 생성한다. - 시작 태그의 뒤 (자식 요소)
                        // 3. beforeend : 타겟 요소 '끝나는 태그' 바로 직전(자식 요소)에 요소를 생성한다. - 종료 태그 앞 (자식 요소)
                        // 4. afterend : 타겟 요소의 '끝나는 태그' 바로 다음(형제 요소)에 요소를 생성한다. - 종료 태그 뒤 (형제 요소)
                        chatArea.insertAdjacentHTML("beforeend", str);
                        // 메시지가 구역을 넘어간다면 해당 구역에 스크롤이 생성되는데 스크롤을 언제나 가장 아래에 위치하게 만든다.
                        chatArea.scrollTop = chatArea.scrollHeight - chatArea.clientHeight;

                        // 작성자가 로그인 유저와 같은 경우 (본인)
                        if ( writer === nickname ) {
                            // 로컬 스토리지를 제거한다.
                            localStorage.clear();
                            // 퇴장 URL에 파라미터로 방 번호와 닉네임을 가져가 퇴장한다.
                            location.href = "/meta/exit?idx=" + metaIdx + "&nickname=" + nickname;
                        // 작성자가 로그인 유저와 다른 경우 (타 유저)
                        } else {
                            // 작성자 닉네임의 id를 통해 참가자 구역에 작성되어 있는 작성자를 가져와 mtr 변수에 저장한다.
                            var mtr = document.getElementById(writer);
                            // mtr에 저장된 참가자 id를 사용하여 해당 참가자를 삭제한다.
                            mtr.remove();
                        }
                    }
                }
            });
        //////////////////////////////////////////////////// 입장 구역 ////////////////////////////////////////////////////
            // 입장 시작!! - 먼저 입장 체크값을 이용하여 해당 유저가 첫 입장인지 재입장(새로고침)인지 체크한다.
            // 첫 입장일 경우 - 입장 체크값이 존재하지 않는다.
            if ( entryCheck == null ) {
                // 시작 시간과 메시지 전송 시간과 전송된 메시지 수와 메시지 전송 상태의 각 변수명을 키로 사용하고, 각 초기값을 지정해 값으로 사용하여 로컬 스토리지에 추가한다.
                localStorage.setItem("start", Date.now()); // Date.now()로 초기화
                localStorage.setItem("end", Date.now()); // Date.now()로 초기화
                localStorage.setItem("count", 0); // 0으로 초기화
                localStorage.setItem("sendMessage", "true"); // true로 초기화
                // 로컬 스토리지에 추가한 값들을 가져와 각 알맞는 변수에 전달한다.
                start = localStorage.getItem("start");
                end = localStorage.getItem("end");
                count = localStorage.getItem("count");
                sendMessage = localStorage.getItem("sendMessage");
                // 4번이 5번보다 아래에 위치한 이유 - 위에 있을경우 간혹 4번에서 전송한 메시지를 제대로 전달받지 못하는 경우가 존재한다.
                // 4. send(path, header, message)로 입장 메시지를 전송한다. (첫 입장할때 딱 한번만 여기서 입장 메시지를 전송한다.)
                //    JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                //    여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                stomp.send('/pub/meta/studyRoom/enter', {}, JSON.stringify({type : "enter", metaIdx : metaIdx, metaTitle : metaTitle, writer : nickname, profileImage : profileImage, metaRecruitingPersonnel : metaRecruitingPersonnel}));
            // 재입장(새로고침)일 경우 - 입장 체크값이 존재한다.
            } else {
                // 4번이 5번보다 아래에 위치한 이유 - 위에 있을경우 간혹 4번에서 전송한 메시지를 제대로 전달받지 못하는 경우가 존재한다.
                // 4. send(path, header, message)로 입장 메시지를 전송한다. (첫 입장 이후 모든 재입장(새로고침)은 여기서 입장 메시지를 전송한다.)
                //    JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                //    여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                stomp.send('/pub/meta/studyRoom/reenter', {}, JSON.stringify({type : "reEnter", metaIdx : metaIdx, writer : nickname, profileImage : profileImage, metaRecruitingPersonnel : metaRecruitingPersonnel}));
            }
        });
        //////////////////////////////////////////////////// 채팅 구역 ////////////////////////////////////////////////////
        // 키가 눌릴 경우 발생하는 이벤트 핸들러 등록
        message.addEventListener("keypress", function(event) {
            // 눌린 키가 무엇인지 체크한다.
            // 눌린 키가 엔터 키인 경우
            if ( event.key === "Enter" ) {
                // 채팅 메시지 전송 메소드로 이동한다.
                send();
            }
        });

        // 채팅 메시지 전송 메소드
        function send() {
            // id를 통해 작성한 메시지를 가져온다.
            let message = document.getElementById("message");
            // 가져온 메시지의 값을 체크한다.
            // 가져온 메시지의 값이 비어있을 경우
            if ( message.value == "" ) {
                // 먼저 경고 알림창을 띄워준다.
                alert("메시지를 작성해주세요.");
                // 그 다음 아무 작업 없이 돌아간다.
                return;
            // 가져온 메시지의 값이 비어있지 않을 경우
            } else {
                // 1초 이내 5개 이상의 메시지를 보낼 경우 - 5초간 메시지를 보낼 수 없다.
                // ( end - start ) - 처음 메시지 전송후 1초 이내 다음 메시지 전송까지의 경과 시간
                if ( ( end - start ) <= 1000 && count >= 5 ) {
                    alert("짧은 시간에 많은 메시지를 보낼 수 없습니다. 잠시 후 다시 시도해주세요.");
                    // 먼저 로컬 스토리지에서 현재 가지고 있는 메시지 전송 상태를 삭제한다.
                    localStorage.removeItem("sendMessage");
                    // 그 다음 메시지 전송 상태 값을 메시지를 보낼 수 없는 상태로 변경하여 다시 로컬 스토리지에 추가한다.
                    localStorage.setItem("sendMessage", "false");
                    // 마지막으로 로컬 스토리지에 다시 추가한 값을 가져와 알맞는 변수에 전달한다.
                    sendMessage = localStorage.getItem("sendMessage");
                    // 5초 대기 후 내부 메소드를 실행한다.
                    setTimeout(function() {
                        // 먼저 로컬 스토리지에서 현재 가지고 있는 시작 시간과 전송된 메시지 수와 메시지 전송 상태를 삭제한다.
                        localStorage.removeItem("start");
                        localStorage.removeItem("count");
                        localStorage.removeItem("sendMessage");
                        // 그 다음 시작 시간과 전송된 메시지 수와 메시지 전송 상태 값을 다시 초기값으로 변경하여 로컬 스토리지에 추가한다.
                        localStorage.setItem("start", Date.now());
                        localStorage.setItem("count", 0);
                        localStorage.setItem("sendMessage", "true");
                        // 마지막으로 로컬 스토리지에 다시 추가한 값들을 가져와 각 알맞는 변수에 전달한다.
                        start = localStorage.getItem("start");
                        count = localStorage.getItem("count");
                        sendMessage = localStorage.getItem("sendMessage");
                    }, 5000);
                // 그 외 경우
                } else {
                    // 메시지를 보낼 수 없는 상태인 경우 - 아직 5초 대기중이다.
                    if ( sendMessage == "false" ) {
                        // 받아온 메시지를 올리지 않고 통과
                        return;
                    // 메시지를 보낼 수 있는 상태인 경우
                    } else {
                        // 먼저 로컬 스토리지에서 현재 가지고 있는 메시지 전송 시간을 삭제한다.
                        localStorage.removeItem("end");
                        // 그 다음 메시지 전송 시간 값을 다시 초기값으로 변경하여 로컬 스토리지에 추가한다.
                        localStorage.setItem("end", Date.now());
                        // 마지막으로 로컬 스토리지에 다시 추가한 값을 가져와 알맞는 변수에 전달한다.
                        end = localStorage.getItem("end");
                        // 메시지를 전송한지 1초가 지날 경우 - 다시 초기 상태로 돌아간다.
                        if ( ( end - start ) > 1000 ) {
                            // 먼저 로컬 스토리지에서 현재 가지고 있는 시작 시간과 전송된 메시지 수를 삭제한다.
                            localStorage.removeItem("start");
                            localStorage.removeItem("count");
                            // 그 다음 시작 시간과 전송된 메시지 수의 값을 다시 초기값으로 변경하여 로컬 스토리지에 추가한다.
                            localStorage.setItem("start", Date.now());
                            localStorage.setItem("count", 0);
                            // 마지막으로 로컬 스토리지에 다시 추가한 값들을 가져와 각 알맞는 변수에 전달한다.
                            start = localStorage.getItem("start");
                            count = localStorage.getItem("count");
                        }
                        // send(path, header, message)로 채팅 메시지를 전송한다. (입장 이후 작성되는 모든 메시지는 여기서 전송한다.)
                        // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                        // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                        stomp.send('/pub/meta/studyRoom/message', {}, JSON.stringify({type : "chat", metaIdx : metaIdx, message : message.value, writer : nickname}));
                        message.value = ""; // 메시지를 전송한 뒤 공백 상태로 만든다.
                        // 먼저 전송된 메시지 수를 1 증가시킨다.
                        count++;
                        // 그 다음 로컬 스토리지에서 현재 가지고 있는 전송된 메시지 수를 삭제한다.
                        localStorage.removeItem("count");
                        // 그 다음 메시지 수의 값을 증가한 값으로 변경하여 다시 로컬 스토리지에 추가한다.
                        localStorage.setItem("count", count);
                        // 마지막으로 로컬 스토리지에 다시 추가한 값을 가져와 알맞는 변수에 전달한다.
                        count = localStorage.getItem("count");
                    }
                }
            }
        }
        ////////////////////////////////////////////////// 녹음 변수 구역 //////////////////////////////////////////////////
        let record = document.getElementById("record"); // 오디오 태그
        let btnRecordStart = document.getElementById("btnRecordStart"); // 녹음 시작 버튼
        let btnRecordStop = document.getElementById("btnRecordStop"); // 녹음 정지 버튼
        let btnRecordSend = document.getElementById("btnRecordSend"); // 녹음 전송 버튼
        let mediaRecorder; // MediaRecorder 객체
        let recordedChunks = []; // blob 녹음 데이터
        let recordTimeoutId; // 녹음 setTimeout ID
        let recordBlob; // 병합한 Blob 녹음 데이터
        let recordUrl; // 병합한 Blob 녹음 데이터의 URL
        //////////////////////////////////////////////////// 녹음 구역 ////////////////////////////////////////////////////
        // 녹음 시작 버튼 클릭 시 호출되는 메소드
        async function startRecording() {
            // navigator.mediaDevices.getUserMedia() - 미디어 스트림(비디오 또는 오디오)을 생성하는 메소드로 비동기 메소드이며, 사용자의 미디어 장치(예: 마이크)를 사용할 수 있는 권한이 있는지를 확인하고, 권한이 있다면 미디어 스트림을 반한다.
            // getUserMedia() 메소드는 mediaDevices 객체에 호출되며, 사용자에게 미디어 장치 사용 권한을 요청한다.
            // getUserMedia()에 전달된 매개변수는 'audio' 속성을 true로 설정하여 사용자의 오디오 장치에 액세스하려는 것을 지정한다.
            // getUserMedia()는 Promise 객체를 반환하며,
            // 요청한 미디어 타입에 대한 스트림을 성공적으로 가져올 경우 then() 메소드를 호출하여 성공적인 MediaStream 객체를 반환한다.
            // 반면, 접근 권한이 거부되거나 미디어 장치가 없는 경우 catch() 메소드를 호출하여 NotAllowedError 또는 NotFoundError 오류를 반환한다.
            // getUserMedia()는 안전한 출처 (즉, localhost, HTTPS)에서만 작동한다.
            navigator.mediaDevices.getUserMedia({ audio: true })
                // then 메소드는 Promise 객체가 resolve된 후 호출된다.
                .then(stream => {
                    try {
                        // 브라우저가 WAV 오디오 형식을 지원하는지 검사한다.
                        // WAV 오디오 형식을 지원하는 경우
                        if ( typeof MediaRecorder.isTypeSupported == "function" && MediaRecorder.isTypeSupported( "audio/wav" ) ) {
                            // MediaRecorder 생성자를 사용하여 입력 스트림(stream)에서 오디오 데이터를 캡처하고,
                            // 해당 데이터의 MIME 타입을 "audio/wav"로 설정하는 MediaRecorder 객체를 생성해 mediaRecorder 변수에 전달한다.
                            // stream(입력 스트림) - getUserMedia() 메소드로 얻은 스트림을 저장하는 변수이며, 이를 MediaRecorder 생성자에 전달하여 오디오 데이터를 캡처한다.
                            mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/wav" });
                        // WAV 오디오 형식을 지원하지 않는 경우
                        } else {
                            // MediaRecorder 생성자를 사용하여 입력 스트림(stream)에서 오디오 데이터를 캡처하고,
                            // 해당 데이터의 MIME 타입을 "audio/webm"으로 설정하는 MediaRecorder 객체를 생성해 mediaRecorder 변수에 전달한다.
                            // stream(입력 스트림) - getUserMedia() 메소드로 얻은 스트림을 저장하는 변수이며, 이를 MediaRecorder 생성자에 전달하여 오디오 데이터를 캡처한다.
                            mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
                        }

                        // MediaRecorder 객체에서 "dataavailable" 이벤트가 발생하면 해당 이벤트를 처리하는 콜백 메소드를 등록한다.
                        // dataavailable - MediaRecorder 객체에서 발생하는 이벤트 중 하나로 MediaRecorder가 녹음을 진행하면서 데이터를 누적할 때마다 발생한다.
                        //                 즉, 녹음된 오디오 데이터가 사용 가능해질 때마다 이 이벤트가 발생한다.
                        //                 이 때 발생한 녹음된 오디오 데이터는 Blob 형태로 event.data에 담긴다.
                        //                 그러기에 이 이벤트를 이용하면 MediaRecorder가 녹음한 오디오 데이터를 직접 다룰 수 있게 된다.
                        mediaRecorder.addEventListener("dataavailable", function(event) {
                            // event.data에 들어있는 녹음된 오디오 데이터가 유효한지 체크한다.
                            // 녹음된 오디오 데이터가 유효하지 않은 경우
                            if (typeof event.data === "undefined") {
                                // 아무 작업 없이 돌아간다.
                                return;
                            // 녹음된 오디오 데이터가 유효한 경우
                            } else {
                                // 녹음된 오디오 데이터를 위에서 미리 만들어둔 recordedChunks 배열에 추가한다.
                                recordedChunks.push(event.data);
                                // Blob 생성자를 사용하여 recordedChunks 배열에 저장된 Blob 오디오 데이터들을 모두 가져와,
                                // MIME 타입을 "audio/webm"으로 설정하는 하나의 Blob 객체로 재생성해,
                                // recordBlob 변수에 전달한다.
                                recordBlob = new Blob(recordedChunks, { type: "audio/webm" });
                                // createObjectURL 메소드를 사용하여 재생성된 Blob 객체를 URL 객체로 변환해,
                                // recordUrl 변수에 전달한다.
                                recordUrl = URL.createObjectURL(recordBlob);
                                // .src를 사용하여 변환된 URL을 id값으로 가져온 현재 작성되어 있는 오디오 태그의 소스로 설정해,
                                // 녹음된 오디오를 전송하기 전에 녹음 내용을 들어 볼 수 있게 한다.
                                record.src = recordUrl;
                            }
                        });

                        // MediaRecorder의 start() 메소드를 호출하여 녹음을 시작한다.
                        mediaRecorder.start();

                        // setTimeout 메소드를 사용하여 녹음이 시작된지 300000ms(5분)이 경과하면 자동으로 녹음이 멈추고,
                        // 이후 녹음을 더 이상 할 수 없도록 막고 초기화와 전송만 가능하도록 한다.
                        // 그리고 recordTimeoutId 변수에 setTimeout 메소드로 반환된 타이머 ID를 저장하여,
                        // 타이머가 실행되는 동안 ID를 사용하여 취소할 수 있도록 한다.
                        recordTimeoutId = setTimeout(function() {
                            // MediaRecorder의 stop() 메소드를 호출하여 녹음을 멈춘다.
                            mediaRecorder.stop();
                            // 초기화 버튼을 활성화한다.
                            btnRecordStart.disabled = false;
                            // 재시작 버튼을 비활성화한다.
                            btnRecordStop.disabled = true;
                            // 전송 버튼을 활성화한다.
                            btnRecordSend.disabled = false;
                        }, 300000);
                    // catch 메소드는 Promise 객체가 reject된 후 호출된다.
                    } catch (error) {
                        // 오류가 발생한 경우, 해당 오류를 콘솔에 출력한다.
                        console.error(error);
                    }
            });
        }

        // 녹음된 오디오 메시지 전송 메소드
        async function sendRecording() {
            // Promise 객체를 생성하여 async/await를 사용해 Blob 객체를 base64 문자열로 인코딩한다.
            // 해당 Promise 객체는 resolve를 호출하여 base64로 인코딩된 오디오 데이터를 반환해 base64Data 변수에 전달한다.
            const base64Data = await new Promise(resolve => {
                // FileReader 객체를 생성한다.
                // FileReader - 웹 API 중 하나로, 클라이언트 측 자바스크립트에서 파일의 내용을 비동기적으로 읽어들일 수 있도록 해주는 객체이다.
                //              이 객체를 이용하여 파일의 내용을 읽을 수 있으며, 이 때 파일의 종류나 형식에 따라 읽어들이는 방식이나 사용 방법이 다를 수 있다.
                const reader = new FileReader();
                // readAsDataURL() 메소드를 사용하여 Blob 객체를 base64 문자열로 변환한다.
                // readAsDataURL() - 메서드는 File 혹은 Blob 객체의 데이터를 읽어와, 해당 데이터를 Data URL 형태로 반환한다.
                //                   이 때 반환된 Data URL은 문자열이며, base64 인코딩된 형태의 데이터를 포함하고 있다.
                reader.readAsDataURL(recordBlob);
                // FileReader 객체에 onloadend 이벤트를 등록하여 파일 읽기 작업이 완료되면 호출될 콜백 메소드를 등록한다.
                reader.onloadend = function() {
                    // Promise 객체에서 resolve 메소드를 호출하고,
                    // reader.result를 사용하여 readAsDataURL()를 통해 변환한 base64 문자열 데이터를 가져와 반환한다.
                    // resolve - Promise 객체에서 성공적으로 실행될 경우에 호출되며, 그 결과 값을 반환한다.
                    //           여기서는 reader.result를 반환하므로, 이후 이 Promise 객체를 사용하는 메소드에서 reader.result 값을 받아 처리할 수 있다.
                    resolve(reader.result);
                }
            });
            // send(path, header, message)를 사용하여 녹음된 오디오 데이터를 메시지로 전송한다. (모든 녹음된 오디오 데이터는 여기서 메시지를 전송한다.)
            // {metaIdx : metaIdx, writer : nickname} - 전송할 메시지의 Header로, Header를 통해 metaIdx와 nickname을 전송한다.
            // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 파라미터를 통해 받는다.
            stomp.send('/pub/meta/studyRoom/record', {metaIdx : metaIdx, writer : nickname}, base64Data);
            // recordedChunks 배열을 초기화한다.
            recordedChunks = [];
            // 오디오 태그에 작성되있는 소스를 초기화한다.
            record.src = "";
            // 병합한 Blob 녹음 데이터의 URL을 초기화한다.
            recordUrl = "";
        }

        // 오디오 태그에서 "ended" 이벤트가 발생하면 해당 이벤트를 처리하는 콜백 메소드를 등록한다.
        // ended - 오디오나 비디오 등의 미디어가 재생이 끝났을 때 발생한다.
        record.addEventListener("ended", function() {
            // 오디오 태그의 재생이 종료되면, 오디오 태그에 작성되어 있는 소스를 그대로 재작성한다.
            // 이는 오디오 재생이 끝나고 다시 재생할 때, 오디오 소스가 초기화되도록 하는 역할을 한다.
            // 이렇게 하는 이유는, 오디오 태그의 재생이 종료되고 나서 다시 오디오 태그가 재생될 때, 병합된 오디오 데이터를 온전히 다시 재생하기 위해서이다.
            // 이렇게 하지 않으면, 오디오 태그의 재생이 종료되고 나서 다시 오디오 태그가 재생될 때, 병합된 오디오 데이터중 마지막 오디오 데이터만 재생된다.
            // 하나의 오디오 데이터는 문제가 없지만, 병합된 여러개의 오디오 데이터는 이런 문제가 발생해 임시방편으로 찾아낸 방법이다.
            record.src = record.src;
        });

        // 시작 및 초기화 버튼에서 "click" 이벤트가 발생하면 해당 이벤트를 처리하는 콜백 메소드를 등록한다.
        btnRecordStart.addEventListener("click", function() {
            // 시작 버튼 이름을 체크한다.
            // "녹음 시작" 버튼을 클릭한 경우
            if ( btnRecordStart.value == "녹음 시작" ) {
                // 녹음 시작 메소드를 호출하여 녹음을 시작한다.
                startRecording();
                // 시작 버튼을 초기화 버튼으로 변경한다.
                btnRecordStart.value = "녹음 초기화";
                // 초기화 버튼을 비활성화한다.
                btnRecordStart.disabled = true;
                // 정지 버튼을 활성화한다.
                btnRecordStop.disabled = false;
                // 전송 버튼을 비활성화한다.
                btnRecordSend.disabled = true;
            // "녹음 초기화" 버튼을 클릭한 경우
            } else {
                // 초기화 버튼을 시작 버튼으로 변경한다.
                btnRecordStart.value = "녹음 시작";
                // 시작 버튼을 활성화한다.
                btnRecordStart.disabled = false;
                // 재시작 버튼을 정지 버튼으로 변경한다.
                btnRecordStop.value = "녹음 정지";
                // 정지 버튼을 비활성화한다.
                btnRecordStop.disabled = true;
                // 전송 버튼을 비활성화한다.
                btnRecordSend.disabled = true;
                // recordedChunks 배열을 초기화한다.
                recordedChunks = [];
                // 현재 오디오 태그에 작성되있는 소스를 초기화한다.
                record.src = "";
            }
        });

        // 정지 및 재시작 버튼에서 "click" 이벤트가 발생하면 해당 이벤트를 처리하는 콜백 메소드를 등록한다.
        btnRecordStop.addEventListener("click", function() {
            // 정지 버튼 이름을 체크한다.
            // "녹음 정지" 버튼을 클릭한 경우
            if ( btnRecordStop.value == "녹음 정지" ) {
                // recordTimeoutId에 저장된 setTimeout ID를 사용하여 실행 중인 타이머를 취소한다.
                clearTimeout(recordTimeoutId);
                // MediaRecorder의 stop() 메소드를 호출하여 녹음을 멈춘다.
                mediaRecorder.stop();
                // 시작 버튼을 초기화 버튼으로 변경한다.
                btnRecordStart.value = "녹음 초기화";
                // 초기화 버튼을 활성화한다.
                btnRecordStart.disabled = false;
                // 정지 버튼을 재시작 버튼으로 변경한다.
                btnRecordStop.value = "녹음 재시작";
                // 재시작 버튼을 활성화한다.
                btnRecordStop.disabled = false;
                // 전송 버튼을 활성화한다.
                btnRecordSend.disabled = false;
            // "녹음 재시작" 버튼을 클릭한 경우
            } else {
                // 오디오 태그에 작성되있는 소스를 초기화한다.
                record.src = "";
                // 병합한 Blob 녹음 데이터의 URL을 초기화한다.
                recordUrl = "";
                // 녹음 시작 메소드를 호출하여 녹음을 재시작한다.
                startRecording();
                // 초기화 버튼을 비활성화한다.
                btnRecordStart.disabled = true;
                // 재시작 버튼을 정지 버튼으로 변경한다.
                btnRecordStop.value = "녹음 정지";
                // 정지 버튼을 활성화한다.
                btnRecordStop.disabled = false;
                // 전송 버튼을 비활성화한다.
                btnRecordSend.disabled = true;
            }
        });

        // 전송 버튼에서 "click" 이벤트가 발생하면 해당 이벤트를 처리하는 콜백 메소드를 등록한다.
        btnRecordSend.addEventListener("click", function() {
            // 녹음된 오디오 메시지 전송 메소드를 호출하여 녹음된 오디오를 메시지로 전송한다.
            sendRecording();
            // 초기화 버튼을 시작 버튼으로 변경한다.
            btnRecordStart.value = "녹음 시작";
            // 시작 버튼을 활성화한다.
            btnRecordStart.disabled = false;
            // 재시작 버튼을 정지 버튼으로 변경한다.
            btnRecordStop.value = "녹음 정지";
            // 정지 버튼을 비활성화한다.
            btnRecordStop.disabled = true;
            // 전송 버튼을 비활성화한다.
            btnRecordSend.disabled = true;
            // recordedChunks 배열을 초기화한다.
            recordedChunks = [];
        });
        ///////////////////////////////////////////////// 페이지 이탈 구역 /////////////////////////////////////////////////
        // 1. 페이지를 이탈하는 기능을 실행할 경우 발생하는 이벤트 핸들러 등록
        // beforeunload - 탭 닫기, 윈도우 닫기, 페이지 닫기, 뒤로가기, 버튼, location.href, 새로고침 등 해당 페이지를 벗어나는 기능을 실행할 경우 항상 실행된다.
        window.addEventListener("beforeunload", handleBeforeUnload);
        // beforeunload 핸들러 메소드
        function handleBeforeUnload(event) {
            // beforeunload 이벤트를 명시적으로 처리하지 않은 경우, 해당 이벤트에 기본 동작을 실행하지 않도록 지정한다.
            event.preventDefault();
            // beforeunload 경고창을 띄워준다. - 따로 메시지 작성을 안한 이유는 각 브라우저마다 기본으로 잡혀있는 메시지가 표시되기 때문이다.
            event.returnValue = "";
        }

        // 2. beforeunload 이벤트에서 반환한 경고창에 따라 <body>태그에 작성한 unload 이벤트에서 확인 및 취소를 체크하고, 확인을 누른 경우에만 지정한 메소드로 이동시킨다.
        // unload - 어떤 방식으로든 페이지를 이탈하면 항상 실행된다.

        // 3. 페이지 이탈 후 퇴장 메시지 전송 메소드 - unload에서 지정한 메소드
        function exit() {
            // 방장 닉네임과 퇴장 유저 닉네임이 동일한지 체크한다.
            // 닉네임이 동일한 경우 - 방장 퇴장
            if ( metaMaster == nickname ) {
                // 방에 참여중인 인원이 몇명인지 체크한다.
                // 참여중인 인원이 방장 혼자인 경우
                if ( metaRecruitingPersonnel == 1 ) {
                    // fetch를 사용하여 방 삭제 URL에 파라미터로 방 번호와 닉네임을 가져가 방 삭제 후 바로 퇴장한다.
                    // fetch(url, options) - 브라우저에서 제공하는 API 중 하나로, 네트워크 요청을 보내고 응답을 받아오는 메소드이다.
                    //                       fetch() 메소드는 첫 번째 인자로 서버에 데이터를 요청할 URL을 전달받고, 두 번째 인자로 선택적으로 HTTP 요청과 관련된 다양한 옵션을 설정하는 객체를 전달받는다.
                    //                       여기서 옵션 객체는 HTTP 요청에 대한 옵션을 설정할 수 있는 여러 가지 속성을 가지고 있는데,
                    //                       예를 들어 method 속성을 이용하여 HTTP 요청 메소드(GET, POST, PUT, DELETE 등)를 지정할 수 있으며,
                    //                       method 속성을 지정하지 않으면 기본적으로 HTTP 요청 메서드는 GET이 된다.
                    //                       그러기에 두 번째 인자로 옵션 객체를 전달하지 않으면 기본적으로 HTTP 요청 메서드는 GET으로 지정된다.
                    //                       또 다른 속성으로는 headers, mode, cache, credentials 등이 있다.
                    //                       fetch() 메소드는 Promise 객체를 반환하며, 이를 통해 비동기적으로 서버로부터 데이터를 받아올 수 있다.
                    //                       응답을 받아오는 데 성공하면 Response 객체를 반환하고, 실패하면 Error 객체를 반환한다.
                    // 예시 - 아래와 같이 fetch 메소드를 사용하여 JSON 데이터를 요청할 수 있다.
                    // fetch("/meta/delete?idx=" + metaIdx)
                    //     .then(response => response.json()) // JSON 형식으로 파싱
                    //     .then(data => console.log(data)) // 응답 데이터 처리
                    //     .catch(error => console.error(error)); // 오류 처리
                    // fetch 메소드는 Promise를 반환하기 때문에, then 메서드를 사용하여 비동기 처리를 할 수 있다.
                    // fetch 메소드를 사용하여 "/meta/delete?idx=1" 주소로 GET 요청을 보내고,
                    // then() 메소드를 사용하여 요청이 성공했을 때 반환된 Response 객체를 json() 메소드를 통해 JSON 형식으로 변환한다.
                    // 그리고 다시 then() 메소드를 사용하여 변환된 JSON 데이터를 콘솔에 출력한다.
                    // 만약 요청이 실패하면 catch 메소드에서 에러를 출력한다.
                    fetch ("/meta/delete?idx=" + metaIdx);
                // 참여중인 인원이 2명 이상인 경우
                } else {
                    // send(path, header, message)로 퇴장 메시지를 전송한다. (퇴장할때 딱 한번만 전송한다.)
                    // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/exit', {}, JSON.stringify({type : "delete", metaIdx : metaIdx, writer : nickname, metaRecruitingPersonnel : metaRecruitingPersonnel, master : metaMaster}));
                }
            // 닉네임이 동일하지 않은 경우 - 유저 퇴장
            } else {
                // send(path, header, message)로 퇴장 메시지를 전송한다. (퇴장할때 딱 한번만 전송한다.)
                // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                stomp.send('/pub/meta/studyRoom/exit', {}, JSON.stringify({type : "exit", metaIdx : metaIdx, writer : nickname, metaRecruitingPersonnel : metaRecruitingPersonnel}));
            }
        }
    </script>

    <!--------------------------------------------------- 캔버스 구역 ---------------------------------------------------->
    <script th:inline="javascript">
        //////////////////////////////////////////////////// 변수 구역 ////////////////////////////////////////////////////
        var metaIdx1 = [[${metaRoom.idx}]]; // 방 번호
        var nickname1 = [[${nickImage.nickname}]]; // 로그인 유저의 닉네임
        var profileImage1 = [[${nickImage.profileImage}]]; // 로그인 유저의 프로필 사진
        let entryCheck1 = [[${entryCheck}]]; // 입장 체크값

        let canvas; // 도화지
        let canvasLeft; // 왼쪽 벽
        let canvasTop; // 위쪽 벽
        let canvasRight; // 오른쪽 벽
        let canvasBottom; // 아래쪽 벽
        let context; // 화가
        let imgC = "imgChar2"; // 그림 이름 받는곳

        let type = ""; // 메시지 타입
        let characters = ""; // 캐릭터 Map - 서버로 보내기용
        let characters1 = ""; // 캐릭터 Map 파싱 - 캔버스에 그리기용
        let character = ""; // 캐릭터 Map의 닉네임 키
        let coordinate = ""; // 캐릭터 Map의 닉네임 키에 해당하는 List 값

        let keycode; // 키보드 키코드

        let imgChar = new Image(); // 캐릭터 이미지
        let imgBg = new Image(); // 배경 이미지
        imgBg.src = "/map/studyRoom.png"; // 배경 이미지 주소

        let a = document.getElementById("canvas").clientWidth;
        let b = "";
        let c = document.getElementById("canvas").clientHeight;
        d = "";

        let x = ""; // 캐릭터 시작 위치 지정
        let y = ""; // 캐릭터 시작 위치 지정
        let w = 20; // 캐릭터 크기 지정 (전체 사이즈의 절반만 작성)
        let h = 20; // 캐릭터 크기 지정 (전체 사이즈의 절반만 작성)
        //////////////////////////////////////////////////// 소켓 구역 ////////////////////////////////////////////////////
        // 소켓 메소드
        var connect = function() {
            // 1. SockJS를 생성한다. (StompWebSocketConfig에서 설정한 Endpoint와 동일하게 맞춰준다.)
            var sockJs1 = new SockJS("/ws/meta");
            // 2. 생성된 SockJS를 Stomp에 전달한다.
            var stomp1 = Stomp.over(sockJs1);

            // 3. connect가 이뤄지면 실행한다.
            stomp1.connect({}, function () {
                // connect가 이뤄지면 콘솔에 로그를 찍는다.
                console.log("STOMP1 Connection");

                // 5. subscribe(path, callback)으로 메시지를 받을 수 있다.
                //    StompChatController에서 SimpMessagingTemplate를 통해 전달한 DTO를 여기서 콜백 메소드 파라미터로 전달 받는다.
                stomp1.subscribe("/sub/meta/studyRoom/canvas/" + metaIdx, function (message) {
                    // 6. JSON.parse(변환 대상) - JSON 문자열을 JavaScript 값이나 객체로 변환한다.
                    //    JSON형식으로 넘어온 DTO를 JavaScript형식으로 변환한다.
                    var content1 = JSON.parse(message.body);
                    // 6-1. 변환된 DTO를 사용하기 편하게 각각 변수에 나눠놓는다.
                    var writer1 = content1.writer; // 작성자
                    var exit1 = content1.exit; // 퇴장 체크값

                    //
                    // 방을 퇴장하는 경우 - 본인은 퇴장하고 없으므로 타 유저인 경우에만 실시간으로 참가자 구역에서 삭제되도록 만든다.
                    if ( exit1 != null ) {
                        characters = exit1;
                        characters1 = JSON.parse(exit1);
                        drawChar();
                    } else {
                        type = content1.type; // 메시지 타입
                        characters = content1.characters; // 캐릭터 Map - 서버로 보내기용
                        characters1 = JSON.parse(characters); // 캐릭터 Map 파싱 - 캔버스에 그리기용

                        // 메시지 타입이 왼쪽이거나 위쪽이거나 오른쪽이거나 아래쪽일 경우
                        if ( type == "left" || type == "top" || type == "right" || type == "bottom" ) {
                            // 캐릭터 그리기 메소드로 이동한다.
                            drawChar();
                        }

                        // 작성자가 로그인 유저와 같은 경우 (본인)
                        if ( nickname1 == writer1 ) {
                            // 메시지 타입이 첫 입장이거나 재입장일 경우
                            if ( type == "enter" || type == "reenter" ) {
                                // 캔버스 메소드로 이동한다.
                                start1();
                            }
                        } else {
                            drawChar();
                        }
                    }
                });
        //////////////////////////////////////////////////// 입장 구역 ////////////////////////////////////////////////////
                // 입장 시작!! - 먼저 입장 체크값을 이용하여 해당 유저가 첫 입장인지 재입장(새로고침)인지 체크한다.
                // 첫 입장일 경우 - 입장 체크값이 존재하지 않는다.
                if ( entryCheck1 == null ) {
                    // 4번이 5번보다 아래에 위치한 이유 - 위에 있을경우 간혹 4번에서 전송한 메시지를 제대로 전달받지 못하는 경우가 존재한다.
                    // 4. send(path, header, message)로 입장 메시지를 전송한다. (첫 입장할때 딱 한번만 여기서 입장 메시지를 전송한다.)
                    //    JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    //    여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/canvas/enter', {}, JSON.stringify({metaIdx : metaIdx1, writer : nickname1, character : profileImage1, type : "enter", x : a / 2, y : (c / 6) * 5}));
                // 재입장(새로고침)일 경우 - 입장 체크값이 존재한다.
                } else {
                    // 4번이 5번보다 아래에 위치한 이유 - 위에 있을경우 간혹 4번에서 전송한 메시지를 제대로 전달받지 못하는 경우가 존재한다.
                    // 4. send(path, header, message)로 입장 메시지를 전송한다. (첫 입장 이후 모든 재입장(새로고침)은 여기서 입장 메시지를 전송한다.)
                    //    JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    //    여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/canvas/reenter', {}, JSON.stringify({metaIdx : metaIdx1, writer : nickname1, character : profileImage1, type : "reenter", x : a / 2, y : (c / 6) * 5}));
                }
            });
        };
        //////////////////////////////////////////////////// 시작 구역 ////////////////////////////////////////////////////
        // 방에 접속하면 가장 먼저 소켓 메소드로 이동한다.
        connect();
        /////////////////////////////////////////////////// 캔버스 구역 ///////////////////////////////////////////////////
        // 캔버스 메소드
        function start1() {
            // canvas id값으로 가져오기
            canvas = document.getElementById("canvas");
            // canvas를 2d로 설정
            context = canvas.getContext("2d");
            // canvas 크기 설정
            setCanvasSize();

            // 캔버스 크기의 절대적 위치
            canvasLeft = 0 + 50; // 왼쪽 벽
            canvasTop = 0 + 50 // 위쪽 벽
            canvasRight = document.getElementById("canvas").clientWidth - 50; // 오른쪽 벽
            canvasBottom = document.getElementById("canvas").clientHeight - 50; // 아래쪽 벽

            // 시작!!
            //runGame();
            // 시작 알람
            // 실행되고있는 AnimationFrame 삭제 - 이 작업을 먼저 안하면 실행중인 AnimationFrame이 제거되지 않고 계속 쌓이게 된다.
            cancelAnimationFrame(runGame);
            // AnimationFrame 실행 (콜백 메소드) - AnimationFrame으로 실행시킬 메소드를 괄호에 넣는다.
            requestAnimationFrame(runGame);
            // 구형 프레임 작동방식 - 그림을 수시로 그려내는 방식으로 로직이 복잡해질시 프레임이 밀려 캐릭터가 버벅거린다.
            // setInterval(runGame);
        }

        // canvas 크기 설정 메소드 (윈도우 크기게 맞게 설정)
        function setCanvasSize() {
            //캔버스의 현재 길이 설정
            canvas.setAttribute("width", document.getElementById("canvas").clientWidth);
            //캔버스의 현재 높이 설정
            canvas.setAttribute("height", document.getElementById("canvas").clientHeight);
        }

        // 시작 메소드
        function runGame() {
            drawAll(); // canvas 위에 이미지를 그려주는 메소드
        }

        // canvas 위에 이미지를 그려주는 메소드
        function drawAll() {
            // canvas의 왼쪽 상단 모서리에서 시작하여 canvas의 전체 영역을 지운다.
            // 새로 받아온 캐릭터 정보들로 다시 그리기 위하여 먼저 캔버스 위에 그려져있는 캐릭터들을 모두 지운다.
            context.clearRect(0, 0, canvas.width, canvas.height);
            // 배경 그리기
            context.drawImage(imgBg, 0, 0, canvas.width, canvas.height);
            for ( character in characters1 ) {
                // 해당 캐릭터의 좌표 정보 배열 가져오기
                coordinate = characters1[character];
                // 좌표 정보 배열에서 각 좌표를 가져와서 캐릭터 그리기
                imgChar.src = "/imagePath/" + coordinate[0]; // 캐릭터 이미지 주소
                context.drawImage(imgChar, coordinate[1]-w, coordinate[2]-h, w*2, h*2);
                context.font = "bold 15px Arial";
                context.fillStyle = "white";
                context.textAlign = "center";
                context.fillText(character, coordinate[1], coordinate[2] - 25);
            }
        }

        // canvas 위에 이미지를 그려주는 메소드
        function drawChar() {
            // canvas의 왼쪽 상단 모서리에서 시작하여 canvas의 전체 영역을 지운다.
            // 새로 받아온 캐릭터 정보들로 다시 그리기 위하여 먼저 캔버스 위에 그려져있는 캐릭터들을 모두 지운다.
            context.clearRect(0, 0, canvas.width, canvas.height);
            for ( character in characters1 ) {
                // 해당 캐릭터의 좌표 정보 배열 가져오기
                coordinate = characters1[character];
                // 좌표 정보 배열에서 각 좌표를 가져와서 캐릭터 그리기
                imgChar.src = "/imagePath/" + coordinate[0]; // 캐릭터 이미지 주소
                context.drawImage(imgChar, coordinate[1]-w, coordinate[2]-h, w*2, h*2);
            }
            cancelAnimationFrame(runGame); // 실행되고있는 AnimationFrame 삭제
            requestAnimationFrame(runGame); // AnimationFrame 실행
        }

        // 키가 눌렸을때 실행되는 메소드 - 이동 상태
        function keyDown() {
            keycode = event.keyCode; // 키보드 키코드
            // 키코드에 따른 이동 분기 결정
            switch(keycode) {
                // 왼쪽으로 이동
                case 37:
                    // send(path, header, message)로 채팅 메시지를 전송한다. (왼쪽 키가 눌릴 경우 여기서 이동 메시지를 전송한다.)
                    // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/canvas/move', {}, JSON.stringify({metaIdx : metaIdx1, writer : nickname1, character : profileImage1, type : "left", canvasLeft : canvasLeft, canvasTop : canvasTop, canvasRight : canvasRight, canvasBottom : canvasBottom}));
                    break;
                // 위로 이동
                case 38:
                    // send(path, header, message)로 채팅 메시지를 전송한다. (위쪽 키가 눌릴 경우 여기서 이동 메시지를 전송한다.)
                    // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/canvas/move', {}, JSON.stringify({metaIdx : metaIdx1, writer : nickname1, character : profileImage1, type : "top", canvasLeft : canvasLeft, canvasTop : canvasTop, canvasRight : canvasRight, canvasBottom : canvasBottom}));
                    break;
                // 오른쪽으로 이동
                case 39:
                    // send(path, header, message)로 채팅 메시지를 전송한다. (오른쪽 키가 눌릴 경우 여기서 이동 메시지를 전송한다.)
                    // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/canvas/move', {}, JSON.stringify({metaIdx : metaIdx1, writer : nickname1, character : profileImage1, type : "right", canvasLeft : canvasLeft, canvasTop : canvasTop, canvasRight : canvasRight, canvasBottom : canvasBottom}));
                    break;
                // 아래로 이동
                case 40:
                    // send(path, header, message)로 채팅 메시지를 전송한다. (아래쪽 키가 눌릴 경우 여기서 이동 메시지를 전송한다.)
                    // JSON.stringify({json형식}) - JavaScript 값이나 객체를 JSON 문자열로 변환한다.
                    // 여기서 전송한 메시지를 StompChatController에 @MessageMapping이 DTO를 통해 받는다.
                    stomp.send('/pub/meta/studyRoom/canvas/move', {}, JSON.stringify({metaIdx : metaIdx1, writer : nickname1, character : profileImage1, type : "bottom", canvasLeft : canvasLeft, canvasTop : canvasTop, canvasRight : canvasRight, canvasBottom : canvasBottom}));
                    break;
            }
        }

        // 눌린 키가 떼졌을때 실행되는 메소드 - 멈춤 상태
        function keyUp() {
            var keycode = event.keyCode; // 키보드 키코드
            // 키코드에 따른 멈춤 분기 결정
            switch(keycode) {
                // x축 멈춤
                case 37:
                case 39:
                    dx = 0;
                    break;
                // y축 멈춤
                case 38:
                case 40:
                    dy = 0;
                    break;
            }
        }
    </script>
</body>
</html>